# To optimise the configurations of energy generation, storage and transmission assets
# Copyright (c) 2019, 2020 Bin Lu, The Australian National University
# Licensed under the MIT Licence
# Correspondence: bin.lu@anu.edu.au

from scipy.optimize import differential_evolution
from argparse import ArgumentParser
import datetime as dt
import csv
import os

parser = ArgumentParser()
parser.add_argument('-i', default=400, type=int, required=False, help='maxiter=4000, 400')
parser.add_argument('-p', default=2, type=int, required=False, help='popsize=2, 10')
parser.add_argument('-m', default=0.5, type=float, required=False, help='mutation=0.5')
parser.add_argument('-r', default=0.3, type=float, required=False, help='recombination=0.3')
parser.add_argument('-e', default=2, type=int, required=False, help='per-capita electricity = 2, 5, 9 MWh/year')
parser.add_argument('-n', default='Super', type=str, required=False, help='Super, SP, KP...')
parser.add_argument('-s', default='existing', type=str, required=False, help='existing,construction')
parser.add_argument('-y', default='import', type=str, required=False, help='import, no_import')
#parser.add_argument('-f', default='HVAC', type=str, required=False, help='ac_flag, no_import')
args = parser.parse_args()

scenario = args.s
node = args.n
percapita = args.e
#ac_flag = args.f
import_flag = (args.y == 'import')

from Input import *
from Simulation import Reliability
from Network import Transmission

def F(x):
    """This is the objective function."""

    # Initialise the optimisation
    S = Solution(x)

    CIndia = np.nan_to_num(np.array(S.CInter))

    if import_flag == True:
        # Simulation with only baseload
        Deficit_energy1, Deficit_power1, Deficit1, DischargePH1, DischargePeaking1, Spillage1 = Reliability(S, baseload=baseload, india_imports=np.zeros(intervals), daily_peaking=daily_peaking, peaking_hours=peaking_hours)
        Max_deficit1 = np.reshape(Deficit1, (-1, 8760)).sum(axis=-1) # MWh per year
        PIndia = Deficit1.max() * pow(10, -3) # GW

        GIndia = resolution * (Max_deficit1).max() / efficiencyPH

        PenPower = abs(PIndia - CIndia.sum()) * pow(10,3)
        PenEnergy = 0
        
        # Simulation with baseload, all existing capacity
        Deficit_energy, Deficit_power, Deficit, DischargePH, DischargePeaking, Spillage = Reliability(S, baseload=baseload, india_imports=np.ones(intervals) * CIndia.sum() * pow(10,3), daily_peaking=daily_peaking, peaking_hours=peaking_hours)

        # Deficit penalty function
        PenDeficit = max(0, Deficit.sum() * resolution - S.allowance)

        # India import profile
        india_imports = np.clip(Deficit1, 0, CIndia.sum() * pow(10,3)) # MW

        # Simulation using the existing capacity generation profiles - required for storage average annual discharge
        Deficit_energy, Deficit_power, Deficit, DischargePH, DischargePeaking, Spillage = Reliability(S, baseload=baseload, india_imports=india_imports, daily_peaking=daily_peaking, peaking_hours=peaking_hours)

        # Discharged energy from storage systems
        GPHES = DischargePH.sum() * resolution / years * pow(10,-6) # TWh per year
    else:
        PenPower = 0
        PenEnergy = 0

        india_imports = np.zeros(intervals)

        # Simulation using the existing capacity generation profiles - required for storage average annual discharge
        Deficit_energy, Deficit_power, Deficit, DischargePH, DischargePeaking, Spillage = Reliability(S, baseload=baseload, india_imports=india_imports, daily_peaking=daily_peaking, peaking_hours=peaking_hours)

        # Deficit penalty function
        PenDeficit = max(0, Deficit.sum() * resolution - S.allowance)

        # Discharged energy from storage systems
        GPHES = DischargePH.sum() * resolution / years * pow(10,-6) # TWh per year

    # Transmission capacity calculations
    TDC = Transmission(S, domestic_only=True, output=True) if 'Super' in node else np.zeros((intervals, len(TLoss)))
    CAC = np.amax(abs(TDC), axis=0) * pow(10, -3) # CDC(k), MW to GW

    # Transmission penalty function
    PenDC = 0

    # Average annual electricity generated by existing capacity
    GHydro = resolution * (baseload.sum() + DischargePeaking.sum()) / efficiencyPH / years
    
    # Average annual electricity imported through external interconnections
    GIndia = resolution * india_imports.sum() / years / efficiencyPH

    # Levelised cost of electricity calculation
    cost = factor * np.array([sum(S.CPV),0, GIndia * pow(10,-6), sum(S.CPHP), S.CPHS, GPHES] + list(CAC) + [sum(S.CPV),0, (GHydro) * pow(10, -6)]) # $b p.a.
    cost = cost.sum()
    loss = np.sum(abs(TDC), axis=0) * TLoss
    loss = loss.sum() * pow(10, -9) * resolution / years # PWh p.a.
    LCOE = cost / abs(energy - loss) 

    if not os.path.exists('Results'):
        os.makedirs('Results')

    with open('Results/record_{}_{}_{}_{}.csv'.format(node, scenario, percapita, import_flag), 'a', newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(np.append(x,[PenDeficit+PenEnergy+PenPower+PenDC,PenDeficit,PenEnergy,PenPower,LCOE]))


    Func = LCOE + PenDeficit + PenEnergy + PenPower + PenDC
    
    return Func

if __name__=='__main__':
    starttime = dt.datetime.now()
    print("Optimisation starts at", starttime)



    lb = pv_lb  + contingency_ph + [0.] + [0.] * inters
    ub = pv_ub + phes_ub + phes_s_ub + inters_ub

    result = differential_evolution(func=F, bounds=list(zip(lb, ub)), tol=0, # init=start,
                                    maxiter=args.i, popsize=args.p, mutation=args.m, recombination=args.r,
                                    disp=True, polish=False, updating='deferred', workers=-1) ###### CHANGE WORKERS BACK TO -1

    with open('Results/Optimisation_resultx_{}_{}_{}_{}.csv'.format(node,scenario,percapita,import_flag), 'w', newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(result.x)

    endtime = dt.datetime.now()
    print("Optimisation took", endtime - starttime)

    from Fill import Analysis
    Analysis(result.x,'_{}_{}_{}_{}.csv'.format(node,scenario,percapita,import_flag))
